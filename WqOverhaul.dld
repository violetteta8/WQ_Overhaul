'Start of Constants Customization Section
Const WqSonde = "WQ_SERIAL_BURST"
'Value = "WQ_SDI12"
'Value = "WQ_SERIAL"
'Value = "WQ_SERIAL_BURST"
'Value = "NONE"
Const WqBaud = 38400
'Value = 38400
'Value = 9600
Const MaxBurstCnt = 30
'Min = 4
'Max = 30
'Inc = 1
Const MaxWqErrCnt = 20
'Min = 5
'Max = 60
'Inc = 5
Const DWRSonde = False
'Value = True
'Value = False
'End of Constants Customization Section

SequentialMode

#If WqSonde <> "NONE" Then 'Define Constants for presence of Sonde
  #If LoggerType = CR1000 Then 'If CR1000
    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then 'If serial
      Const WqSerialPort = Com4
    #Else 'if SDI12
      Const WqCom3 = 3
      Const WqCom5 = 5
    #EndIf 'If serial or SDI12
    Const WqSwitchPort = 6
  #ElseIf LoggerType = CR6 Then 'If CR6
    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then 'If serial
      Const WqSerialPort = ComC3 'WQ must use a C port
    #ElseIf WqSonde = "WQ_SDI12" Then 'If SDI12
      Const WqCom3 = U3
      Const WqCom5 = U5
    #EndIf 'If serial or SDI12
    Const WqSwitchPort = U6
    Const UseSW12_2_forWQ = False
  #EndIf 'LoggerType conditional
#EndIf'If WqSonde <> "NONE"

'Declare Univeral Variables, regardless of WqSonde argument
Const BadDataIndicator = NAN

Public SiteID As String * 6
Public SiteNum As Float
Public StationVolts, LoggerTempC 'Simple Logger diagnostics

'Declare Timer Variables
Dim DebugTimer 'Name for timer used for Scan timing checks
Dim ModStart, ModEnd, ModTot, ScanTot 'Variables to hold start, end, and processing time of "ModTime" calculation
#If WqSonde <> "NONE" Then
  Dim PwrWqStart, PwrWqEnd, PwrWqTot, CycleWqStart, CycleWqEnd, CycleWqTot, RedeployStart, RedeployEnd, RedeployTot
  Dim DefineLocsStart, DefineLocsEnd, DefineLocsTot, ParamOrdStart, ParamOrdEnd, ParamOrdTot, GetWQStart, GetWQEnd, GetWQTot
  Dim ParseWQStart, ParseWQEnd, ParseWQTot
  #If DWRSonde = False Then
    Dim MarkWQBadStart, MarkWQBadEnd, MarkWQBadTot
  #EndIf
  #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then 'if serial comms define serial related timers
    Dim OpenWqPortStart, OpenWqPortEnd, OpenWqPortTot, WipeWqStart, WipeWqEnd, WipeWqTot
    Dim SetEXOTimeStart, SetEXOTimeEnd, SetEXOTimeTot
    #If WqSonde = "WQ_SERIAL_BURST" Then 'if we are using burst, define burst related timers
      Dim BurstDelayStart, BurstDelayEnd, BurstDelayTot, SetBurstStart, SetBurstEnd, SetBurstTot, BuildBurstStart, BuildBurstEnd, BuildBurstTot
      Dim DeconBurstStart, DeconBurstEnd, DeconBurstTot, ParseBurstStart, ParseBurstEnd, ParseBurstTot, CopyBurstStart, CopyBurstEnd, CopyBurstTot
      Dim ResetBurstStart, ResetBurstEnd, ResetBurstTot
    #EndIf 'If burst
  #EndIf 'If serial
#EndIf 'If Sonde <> NONE

Dim RealSeconds, Mod5Minutes, Mod15Minutes, Mod60Minutes, ModDay
Dim rTime(9)
Alias rTime(3) = DOM 'Day of Month
Alias rTime(4) = Hour
Alias rTime(5) = Minute
Alias rTime(6) = Second
Alias rTime(7) = MicroSecond
Alias rTime(8) = DOW 'Day of Week

Dim Rec15MinFlag As Boolean 'AQ Table Trigger
#If WqSonde = "WQ_SERIAL_BURST" Then
  Dim BurstMissed As Boolean
  Dim RecBurstFlag As Boolean
  Dim BurstPeriod 'Do we want this Public in the future?
#EndIf

'Mod Timing used to trigger time-based events, tables, sampling using scan rate interval
Sub ModTiming
  ModStart = Timer(DebugTimer,mSec,4)
  ModStart = ModStart/1000
  RealTime (rTime)'get current time from datalogger real time clock, stores in rTime() array
  RealSeconds = (Hour * 3600) + (Minute * 60) + Second 'convert hours, minutes, seconds to seconds
  Mod5Minutes = RealSeconds MOD 300 'calculate period into a 5min interval
  Mod15Minutes = RealSeconds MOD 900 'calculate period into a 15min interval
  Mod60Minutes = RealSeconds MOD 3600 'calculate period into 60min interval
  ModDay = RealSeconds MOD 86400 'calculate period into a 24hr period
  If Mod15Minutes = 0 Then
    Rec15MinFlag = True
  Else
    Rec15MinFlag = False
  EndIf
  ModEnd = Timer(DebugTimer,mSec,4)
  ModEnd = ModEnd/1000
  ModTot = ModEnd - ModStart
EndSub

Sub ResetTimers
  ModStart = 0
  ModEnd = 0
  ModTot = 0
  #If WqSonde <> "NONE" Then
    PwrWqStart = 0
    PwrWqEnd = 0
    PwrWqTot = 0
    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
      SetEXOTimeStart = 0
      SetEXOTimeEnd = 0
      SetEXOTimeTot = 0
    #EndIf
    RedeployStart = 0
    RedeployEnd = 0
    RedeployTot = 0
    ParamOrdStart = 0
    ParamOrdEnd = 0
    ParamOrdTot = 0
    DefineLocsStart = 0
    DefineLocsEnd = 0
    DefineLocsTot = 0
    '    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
    '      SetDelimStart = 0
    '      SetDelimEnd = 0
    '      SetDelimTot = 0
    '    #EndIf
    CycleWqStart = 0
    CycleWqEnd = 0
    CycleWqTot = 0
    GetWQStart = 0
    GetWQEnd = 0
    GetWQTot = 0
    ParseWQStart = 0
    ParseWQEnd = 0
    ParseWQTot = 0
    WipeWqStart = 0
    WipeWqEnd = 0
    WipeWqTot = 0
    #If WqSonde = "WQ_SERIAL_BURST" Then
      BurstDelayStart = 0
      BurstDelayEnd = 0
      BurstDelayTot = 0
      SetBurstStart = 0
      SetBurstEnd = 0
      SetBurstTot = 0
      BuildBurstStart = 0
      BuildBurstEnd = 0
      BuildBurstTot = 0
      DeconBurstStart = 0
      DeconBurstEnd = 0
      DeconBurstTot = 0
      ParseBurstStart = 0
      ParseBurstEnd = 0
      ParseBurstTot = 0
    #EndIf 'If BURST
  #EndIf 'If Sonde Present
EndSub

#If WqSonde <> "NONE" Then 'If we have a sonde

  'Declare Global WQ Variables
  Public IsWQNClosed As Boolean = True
  Public Redeploy As Boolean = True 'Default to immediately go into Redeploy mode on compile
  Public WqManualCycle As Boolean
  Public WqPwrCycleCnt As Float

  'Error Checking Variables and Flags
  Dim OldEXOTime
  Public WqError As Boolean
  Public WqDead As Boolean
  Public WqErrCount
  #If WqSonde <> "WQ_SERIAL_BURST" Then
    Public ErrEvent(4) As String * 50
    Alias ErrEvent(1) = WqSysInfo
    Alias ErrEvent(2) = WqCycleErr 'used to trigger SiteVisit table to be written/record reason table was triggered
    Alias ErrEvent(3) = RedeployErr
    Alias ErrEvent(4) = WqDataErr
  #Else
    Public ErrEvent(7) As String * 50
    Alias ErrEvent(1) = WqSysInfo
    Alias ErrEvent(2) = WqCycleErr 'used to trigger SiteVisit table to be written/record reason table was triggered
    Alias ErrEvent(3) = RedeployErr
    Alias ErrEvent(4) = WqDataErr
    Alias ErrEvent(5) = WqBurstErr
    Alias ErrEvent(6) = WqBurstTableErr
    Alias ErrEvent(7) = WqBurstAQErr
  #EndIf

  'Variables for storing single point data
  Dim WqDate, WqTime, WqTempC, WqTempF, WqSpCond, WqTurbFNU, WqDOsat, WqDOmgL, WqDepthFt, WqDepthM, WqBattV, WqpH, WqpHmV, WqORP,
  Dim WqChlugL, WqChlRFU, WqBGArfu, WqBGAugL, WqFdomRFU, WqFdomQSU, WqNH4mgL, WqNO3mgL, WqCLmgL, WqWiperPos

  'Variables for Parameter Order definition
  Const WqNParams = 24
  Dim WqParamOrder(WqNParams)
  Dim t(WqNParams)
  Dim WqData(WqNParams)
  Dim WqLocDate, WqLocTime, WqLocTempC, WqLocTempF, WqLocSpC, WqLocTurbFNU, WqLocDOSat, WqLocDOmgL, WqLocDepthFt, WqLocDepthM
  Dim WqLocBatt, WqLocpH, WqLocpHmV, WqLocORP, WqLocChlugL, WqLocChlRFU, WqLocBGApcRFU, WqLocBGApcugL, WqLocFdomRFU, WqLocFdomQSU
  Dim WqLocNH4, WqLocNO3, WqLocCL, WqLocWiperPos

  'Parameter Codes
  Dim DateCode = 52, TimeCode = 54, TempCCode = 1, TempFcode = 2, SpCcode = 7, TurbFNUcode = 223, DoSatCode = 211, DOmgLCode = 212
  Dim DepthFtCode = 23, DepthMcode = 22, BattCode = 28, pHCode = 18, pHmVcode = 17, ChlugLCode = 193, ChlRFUCode = 194, BGApcRFUCode = 216
  Dim BGApcugLCode = 225, FDomRFUcode = 227, FDomQSU = 228, ORPCode = 19, NH4Code = 48, NO3Code = 106, CLCode = 112, WiperPosCode = 229


  'Declare WQ Communications Variables
  #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then 'If sonde uses serial comms
    Public WqIn As String * 200
    Public WqInLen
    Public NoSondeTrig As String * 10
    #If LoggerType = CR1000 Then
      Dim IsWqMax232 As Boolean 'Only using Max232 for CR1000s currently
    #EndIf
    #If LoggerType = CR6 Then
      Dim UseCommsOneForSonde As Boolean
      Dim UseCommsZeroForSonde As Boolean
    #EndIf
  #ElseIf WqSonde = "WQ_SDI12" Then 'If sonde uses SDI12 comms
    Public WqSDIPort 'Port for Wq Sonde
    Public WqAddr 'SDI12 Address for sonde 1
  #EndIf 'Serial or SDI12 conditional
#EndIf 'If sonde <> NONE


'Table Definitions
DataTable(Aquarius,Rec15MinFlag,-1)
  CardOut(0,17280)
  OpenInterval
  Minimum (1,StationVolts,FP2,False,False)
  Average (1,LoggerTempC,FP2,False)
  #If WqSonde = "WQ_SERIAL_BURST" Then
    Sample (1,MedBurstDate,IEEE4)
    Sample (1,MedBurstTime,IEEE4)
    Minimum (1,WqBattV,FP2,False,False)
    Sample (1,MedTempC,IEEE4) 'the "Med..." values are pulled from the burst table via "Med... = Burst.BurstMed..."
    Sample (1,MedSpCond,IEEE4)
    Sample (1,MedTurbFNU,IEEE4)
    Sample (1,MedDOsat,IEEE4)
    Sample (1,MedDOmgL,IEEE4)
    Sample (1,MedDepthFt,IEEE4)
    Sample (1,MedBattV,FP2)
    Sample (1,MedpH,IEEE4)
    Sample (1,MedChlugL,IEEE4)
    Sample (1,MedChlRFU,IEEE4)
    Sample (1,MedFdomRFU,IEEE4)
    Sample (1,MedFdomQSU,IEEE4)
    Sample (1,MedBGArfu,IEEE4)
    Sample (1,MedBGAugL,IEEE4)
  #ElseIf WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SDI12" Then
    Sample (1,WqDate,IEEE4)
    Sample (1,WqTime,IEEE4)
    Minimum (1,WqBattV,FP2,False,False)
    Sample (1,WqTempC,IEEE4)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,IEEE4)
    Sample (1,WqDOsat,IEEE4)
    Sample (1,WqDOmgL,IEEE4)
    Sample (1,WqDepthFt,IEEE4)
    Sample (1,WqDepthM,IEEE4)
    Sample (1,WqBattV,IEEE4)
    Sample (1,WqpH,IEEE4)
    Sample (1,WqChlugL,IEEE4)
    Sample (1,WqChlRFU,IEEE4)
    Sample (1,WqFdomRFU,IEEE4)
    Sample (1,WqFdomQSU,IEEE4)
  #EndIf
EndTable

DataTable(Debugger,True,1440)
  CardOut(0,43200)
  Sample(1,ScanTot,FP2)
  Sample(1,ModStart,FP2)
  Sample(1,ModEnd,FP2)
  Sample(1,ModTot,FP2)
  #If WqSonde <> "NONE" Then
    Sample(1,PwrWqStart,FP2)
    Sample(1,PwrWqEnd,FP2)
    Sample(1,PwrWqTot,FP2)
    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
      Sample(1,SetEXOTimeStart,FP2)
      Sample(1,SetEXOTimeEnd,FP2)
      Sample(1,SetEXOTimeTot,FP2)
    #EndIf
    Sample(1,RedeployStart,FP2)
    Sample(1,RedeployEnd,FP2)
    Sample(1,RedeployTot,FP2)
    Sample(1,ParamOrdStart,FP2)
    Sample(1,ParamOrdEnd,FP2)
    Sample(1,ParamOrdTot,FP2)
    Sample(1,DefineLocsStart,FP2)
    Sample(1,DefineLocsEnd,FP2)
    Sample(1,DefineLocsTot,FP2)
'    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
'      Sample(1,SetDelimStart,FP2)
'      Sample(1,SetDelimEnd,FP2)
'      Sample(1,SetDelimTot,FP2)
'    #EndIf
    Sample(1,CycleWqStart,FP2)
    Sample(1,CycleWqEnd,FP2)
    Sample(1,CycleWqTot,FP2)
    Sample(1,GetWQStart,FP2)
    Sample(1,GetWQEnd,FP2)
    Sample(1,GetWQTot,FP2)
    Sample(1,ParseWQStart,FP2)
    Sample(1,ParseWQEnd,FP2)
    Sample(1,ParseWQTot,FP2)
    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
      Sample(1,WipeWqStart,FP2)
      Sample(1,WipeWqEnd,FP2)
      Sample(1,WipeWqTot,FP2)
      #If WqSonde = "WQ_SERIAL_BURST" Then
        Sample(1,BurstDelayStart,FP2)
        Sample(1,BurstDelayEnd,FP2)
        Sample(1,BurstDelayTot,FP2)
        Sample(1,SetBurstStart,FP2)
        Sample(1,SetBurstEnd,FP2)
        Sample(1,SetBurstTot,FP2)
        Sample(1,BuildBurstStart,FP2)
        Sample(1,BuildBurstEnd,FP2)
        Sample(1,BuildBurstTot,FP2)
        Sample(1,DeconBurstStart,FP2)
        Sample(1,DeconBurstEnd,FP2)
        Sample(1,DeconBurstTot,FP2)
        Sample(1,ParseBurstStart,FP2)
        Sample(1,ParseBurstEnd,FP2)
        Sample(1,ParseBurstTot,FP2)
      #EndIf 'If Burst
    #EndIf 'If Serial
    Sample(1,Redeploy,Boolean)
    #If WqSonde <> "WQ_SERIAL_BURST" Then
      Sample(4,ErrEvent(),String)
    #Else
      Sample(7,ErrEvent(),String)
    #EndIf
  #EndIf 'If Has Sonde
EndTable

#If WqSonde <> "NONE" Then 'If we have a sonde
  #If WqSonde = "WQ_SERIAL_BURST" Then
    DataTable(Burst,RecBurstFlag,1600)
      CardOut (0,17280)
      OpenInterval
      Sample (1,SiteID,String)
      Sample (1,SiteNum,String)
      Sample (1,BurstDate,IEEE4)
      Sample (1,BurstTime,IEEE4)
      Sample (1, BurstPeriod, IEEE4)
      Median (1,BurstDate,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstTime,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstTempC,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstTempF,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstSpCond,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstTurbFNU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstDOsat, MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstDOmgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstORP,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstDepthFt,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstDepthM,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstBattV,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BurstpH,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BurstpHmV,MaxBurstCnt,FP2,BurstMissed)
      Median (1,BurstChlugL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstChlRFU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstBGArfu,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstBGAugL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstFdomRFU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstFdomQSU,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstNH4mgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstNO3mgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstCLmgL,MaxBurstCnt,IEEE4,BurstMissed)
      Median (1,BurstWiperPos,MaxBurstCnt,FP2,BurstMissed)
      StdDev (1,BurstTempC,IEEE4,False)
      Minimum (1,BurstTempC,IEEE4,False,0)
      Maximum (1,BurstTempC,IEEE4,False,0)
      StdDev (1,BurstSpCond,IEEE4,False)
      Minimum (1,BurstSpCond,IEEE4,False,0)
      Maximum (1,BurstSpCond,IEEE4,False,0)
      StdDev (1,BurstTurbFNU,IEEE4,False)
      Minimum (1,BurstTurbFNU,IEEE4,False,0)
      Maximum (1,BurstTurbFNU,IEEE4,False,0)
      StdDev (1,BurstDOsat,IEEE4,False)
      Minimum (1,BurstDOsat,IEEE4,False,0)
      Maximum (1,BurstDOsat,IEEE4,False,0)
      StdDev (1,BurstDOmgL,IEEE4,False)
      Minimum (1,BurstDOmgL,IEEE4,False,0)
      Maximum (1,BurstDOmgL,IEEE4,False,0)
      StdDev (1,BurstORP,IEEE4,False)
      Minimum (1,BurstORP,IEEE4,False,0)
      Maximum (1,BurstORP,IEEE4,False,0)
      StdDev (1,BurstDepthFt,IEEE4,False)
      Minimum (1,BurstDepthFt,IEEE4,False,0)
      Maximum (1,BurstDepthFt,IEEE4,False,0)
      StdDev (1,BurstDepthM,IEEE4,False)
      Minimum (1,BurstDepthM,IEEE4,False,0)
      Maximum (1,BurstDepthM,IEEE4,False,0)
      StdDev (1,BurstBattV,FP2,False)
      Minimum (1,BurstBattV,FP2,False,0)
      Maximum (1,BurstBattV,FP2,False,0)
      StdDev (1,BurstpH,FP2,False)
      Minimum (1,BurstpH,FP2,False,0)
      Maximum (1,BurstpH,FP2,False,0)
      StdDev (1,BurstpHmV,FP2,False)
      Minimum (1,BurstpHmV,FP2,False,0)
      Maximum (1,BurstpHmV,FP2,False,0)
      StdDev (1,BurstChlugL,IEEE4,False)
      Minimum (1,BurstChlugL,IEEE4,False,0)
      Maximum (1,BurstChlugL,IEEE4,False,0)
      StdDev (1,BurstChlRFU,IEEE4,False)
      Minimum (1,BurstChlRFU,IEEE4,False,0)
      Maximum (1,BurstChlRFU,IEEE4,False,0)
      StdDev (1,BurstBGArfu,IEEE4,False)
      Minimum (1,BurstBGArfu,IEEE4,False,0)
      Maximum (1,BurstBGArfu,IEEE4,False,0)
      StdDev (1,BurstBGAugL,IEEE4,False)
      Minimum (1,BurstBGAugL,IEEE4,False,0)
      Maximum (1,BurstBGAugL,IEEE4,False,0)
      StdDev (1,BurstFdomRFU,IEEE4,False)
      Minimum (1,BurstFdomRFU,IEEE4,False,0)
      Maximum (1,BurstFdomRFU,IEEE4,False,0)
      StdDev (1,BurstFdomQSU,IEEE4,False)
      Minimum (1,BurstFdomQSU,IEEE4,False,0)
      Maximum (1,BurstFdomQSU,IEEE4,False,0)
      StdDev (1,BurstNH4mgL,IEEE4,False)
      Minimum (1,BurstNH4mgL,IEEE4,False,0)
      Maximum (1,BurstNH4mgL,IEEE4,False,0)
      StdDev (1,BurstNO3mgL,IEEE4,False)
      Minimum (1,BurstNO3mgL,IEEE4,False,0)
      Maximum (1,BurstNO3mgL,IEEE4,False,0)
      StdDev (1,BurstCLmgL,IEEE4,False)
      Minimum (1,BurstCLmgL,IEEE4,False,0)
      Maximum (1,BurstCLmgL,IEEE4,False,0)
      StdDev (1,BurstWiperPos,FP2,False)
      Minimum (1,BurstWiperPos,FP2,False,0)
      Maximum (1,BurstWiperPos,FP2,False,0)
      Sample (1,TotalBurstVals,FP2)
      Sample (1,BurstMissed,Boolean)
      Sample (1,BurstErrCnt,FP2)
    EndTable

    DataTable(SecBurst,True,900)
      CardOut (0,350000)
      OpenInterval
      Sample (1,SiteID,String)
      Sample (1,SiteNum,String)
      Sample (1,BurstDate,IEEE4)
      Sample (1,BurstTime,IEEE4)
      Sample (1,BurstTempC,IEEE4)
      Sample (1,BurstTempF,IEEE4)
      Sample (1,BurstSpCond,IEEE4)
      Sample (1,BurstTurbFNU,IEEE4)
      Sample (1,BurstDOsat,IEEE4)
      Sample (1,BurstDOmgL,IEEE4)
      Sample (1,BurstORP,IEEE4)
      Sample (1,BurstDepthFt,IEEE4)
      Sample (1,BurstDepthM,IEEE4)
      Sample (1,BurstBattV,FP2)
      Sample (1,BurstpH,FP2)
      Sample (1,BurstpHmV,FP2)
      Sample (1,BurstChlugL,IEEE4)
      Sample (1,BurstChlRFU,IEEE4)
      Sample (1,BurstBGArfu,IEEE4)
      Sample (1,BurstBGAugL,IEEE4)
      Sample (1,BurstFdomRFU,IEEE4)
      Sample (1,BurstFdomQSU,IEEE4)
      Sample (1,BurstNH4mgL,IEEE4)
      Sample (1,BurstNO3mgL,IEEE4)
      Sample (1,BurstCLmgL,IEEE4)
      Sample (1,BurstWiperPos,FP2)
      Sample (1,TotalBurstVals,FP2)
      Sample (1,BurstMissed,Boolean)
      Sample (1,BurstErrCnt,FP2)
    EndTable
  #EndIf

  DataTable (SVMaq,True,-1)
    Sample (1,WqDate,IEEE4)
    Sample (1,WqTime,IEEE4)
    Sample (1,WqTempC,FP2)
    Sample (1,WqTempF,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,IEEE4)
    Sample (1,WqDOsat,IEEE4)
    Sample (1,WqDOmgL,IEEE4)
    Sample (1,WqDepthFt,FP2)
    Sample (1,WqDepthM,FP2)
    Sample (1,WqBattV,FP2)
    Sample (1,WqpH,FP2)
    Sample (1,WqpHmV,IEEE4)
    Sample (1,WqORP,IEEE4)
    Sample (1,WqChlugL,IEEE4)
    Sample (1,WqChlRFU,IEEE4)
    Sample (1,WqBGArfu,IEEE4)
    Sample (1,WqBGAugL,IEEE4)
    Sample (1,WqFdomRFU,IEEE4)
    Sample (1,WqFdomQSU,IEEE4)
    Sample (1,WqNH4mgL,IEEE4)
    Sample (1,WqNO3mgL,IEEE4)
    Sample (1,WqCLmgL,IEEE4)
    Sample (1,WqWiperPos,FP2)
  EndTable

  'Start WQ Subroutine Section

  Sub PowerWqSonde 'Keep power on to sonde
    PwrWqStart = Timer(DebugTimer,mSec,4)
    PwrWqStart = PwrWqStart/1000
    #If LoggerType = CR1000 Then 'If CR1000
      If IsWQNClosed Then 'If we have a normally closed relay in the Sonde circuit
        PortSet(WqSwitchPort,0) 'if normally closed relay, don't send signal to relay
      Else
        PortSet(WqSwitchPort,1) 'if normally open, send signal to relay
      EndIf 'Normally closed relay argument
    #ElseIf LoggerType = CR6 Then 'if CR6
      If UseSW12_2_forWQ Then 'use the SW12 port no 2
        SW12(2,1) 'keep SW12v port powered at all times
      Else 'Not using the SW12_2 port for sonde power
        If IsWQNClosed Then 'if not powered by SW12 and it's on a normally closed relay
          PortSet(WqSwitchPort,0) 'don't send signal to relay
        Else
          PortSet(WqSwitchPort,1) 'not on SW12 and on a normally open relay, send signal
        EndIf 'if normally closed relay argument
      EndIf 'if using SW12_2 argument
    #EndIf 'CR1000 or CR6 conditional
    PwrWqEnd = Timer(DebugTimer,mSec,4)
    PwrWqEnd = PwrWqEnd/1000
    PwrWqTot = PwrWqEnd - PwrWqStart
  EndSub 'Power Sonde

  Sub CycleWQPower 'Cycle power to sonde if there's an error or user wants to cycle
    CycleWqStart = Timer(DebugTimer,mSec,4)
    CycleWqStart = CycleWqStart/1000
    #If LoggerType = CR1000 Then 'If CR1000
      If IsWQNClosed Then 'If normally closed circuit
        PortSet(WqSwitchPort,1) 'send signal to relay to power down sonde
      Else 'if not normally closed circuit
        PortSet(WqSwitchPort,0) 'remove signal to relay to power down sonde
      EndIf 'is normally closed argument
    #ElseIf LoggerType = CR6 Then 'If CR6
      If  UseSW12_2_forWQ Then 'using SW12_2
        SW12(2,0) 'remove power from SW12_2
      Else 'If not using SW12_2
        If IsWQNClosed Then 'if it's a normally closed circuit
          PortSet(WqSwitchPort,1) 'send signal to relay to power down sonde
        Else 'if not normally closed
          PortSet(WqSwitchPort,0) 'remove signal to relay to power down sonde
        EndIf 'if normally closed argument
      EndIf 'if SW12_2 argument
    #EndIf 'End CR1000 or CR6 conditional
    WqPwrCycleCnt = 0 'reset power cycle counter
    WqManualCycle  = False 'reset manual trigger to false
    WqCycleErr = "Cycled Power @ " + Status.Timestamp + "!" 'set error text to store in table
    Redeploy = True 'trigger "Redeploy" sequence
    CycleWqEnd = Timer(DebugTimer,mSec,4)
    CycleWqEnd = CycleWqEnd/1000
    CycleWqTot = CycleWqEnd - CycleWqStart
  EndSub 'cycle power sub

  Sub ResetErr
    ErrEvent() = ""
  EndSub

  #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then 'if using any serial, immediately define serial port settings
    Sub OpenWQPort 'Open serial port based on LoggerType, Baudrates, and Max232 presence
      OpenWqPortStart = Timer(DebugTimer,mSec,4)
      OpenWqPortStart = OpenWqPortStart/1000
      #If LoggerType = CR6 'For a CR6 the port require a different configuration from a CR1000
        If UseCommsOneForSonde = True Then
          SerialOpen (WqSerialPort,WqBaud,19,0,2000,1)'Max232 requires us to use TTL language, use comms mode one.The Max232 also converts to a binary like signal and requires serial open format of 19 to function. Standard code zero results in a communication error.
        ElseIf UseCommsZeroForSonde = True Then
          SerialOpen (WqSerialPort,WqBaud,0,0,2000,0)'No Max232 is present so we uses standard RS232 language
        Else
          SerialOpen (WqSerialPort,WqBaud,0,0,2000)'In case we use a non-stanadard port configuration this is the generic code
        EndIf 'Comms Mode arguments
      #ElseIf LoggerType = CR1000 Then 'else it is a CR1000
        If (IsWqMax232 = True) AND (WqSerialPort <> ComME) Then 'Using MAX232 but NOT on the CS-I/O port (Defined ComME)
          SerialOpen (WqSerialPort,WqBaud,19,0,2000)'need to use TTL if Max232 is present, Format 19
        Else
          SerialOpen (WqSerialPort,WqBaud,0,0,2000)'standard RS232 language works if no Max232 is present, Format 0
        EndIf 'Max232 and ComME argument
      #EndIf 'End CR1000 or CR6 conditional
      OpenWqPortEnd = Timer(DebugTimer,mSec,4)
      OpenWqPortEnd = OpenWqPortEnd/1000
      OpenWqPortTot = OpenWqPortEnd - OpenWqPortStart
    EndSub 'Open Serial Port sub
  #EndIf 'If using serial conditional

  Sub Redeployment 'gets the parameter codes from the EXO in whichever order they're being output
    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then ' If it's a serial connection
      RedeployStart = Timer(DebugTimer,mSec,4)
      RedeployStart = RedeployStart/1000
      Call OpenWQPort 'open the port
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10) 'a zero is required to wake up the sonde for other commands to be recieved. if not sonde will respond with"command?"
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setsonde 0"+CHR(13)+CHR(10),"OK",3,50)'configure logger/SOA to talk to the top sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10) 'after choosing which sonde to talk to, another zero must be sent to wake it up again.
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"para" + CHR(13) + CHR(10),"",1,0)'gives the parameter order
      Delay (1,300,mSec)
      SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
      WqIn = Trim(WqIn)
      SplitStr (WqParamOrder,WqIn,CHR(32),WqNParams,0)
      WqInLen = Len(WqIn)
      NoSondeTrig = InStr(1,WqIn,"Sonde",2)
      If NoSondeTrig <> 0 Then
        RedeployErr = "SOA: No Sonde!"
        Redeploy = True
        SerialFlush(WqSerialPort)
        RedeployEnd = Timer(DebugTimer,mSec,4)
        RedeployEnd = RedeployEnd/1000
        RedeployTot = RedeployEnd - RedeployStart
        ExitSub
      EndIf
      If WqInLen = 0 Then
        RedeployErr = "No response from sonde!"
        Redeploy = True
        SerialFlush(WqSerialPort)
        RedeployEnd = Timer(DebugTimer,mSec,4)
        RedeployEnd = RedeployEnd/1000
        RedeployTot = RedeployEnd - RedeployStart
        ExitSub
      EndIf
      Delay (1,20,mSec)
      SerialFlush(WqSerialPort)
      Delay (1,10,mSec
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setsonde 0"+CHR(13)+CHR(10),"OK",3,50)'set to communicate to top sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setdelim 2" + CHR(13) + CHR(10),"OK",3,50) 'set to comma delimited
      Delay (1,300,mSec)
      SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
      NoSondeTrig = InStr(1,WqIn,"Sonde",2)
      WqInLen = Len(WqIn)
      If NoSondeTrig <> 0 Then
        RedeployErr = "SOA: No Sonde!"
        Redeploy = True
        SerialFlush(WqSerialPort)
        RedeployEnd = Timer(DebugTimer,mSec,4)
        RedeployEnd = RedeployEnd/1000
        RedeployTot = RedeployEnd - RedeployStart
        ExitSub
      EndIf
      If WqInLen = 0 Then
        RedeployErr = "No response from sonde!"
        Redeploy = True
        SerialFlush(WqSerialPort)
        RedeployEnd = Timer(DebugTimer,mSec,4)
        RedeployEnd = RedeployEnd/1000
        RedeployTot = RedeployEnd - RedeployStart
        ExitSub
      EndIf
      Delay (1,20,mSec)
      SerialFlush(WqSerialPort)
    #ElseIf WqSonde = "WQ_SDI12" Then 'if using SDI12
      Dim SDIcodes(3) As String * 50
      Dim FullSDICodes As String * 150
      'Use extended SDI12 command 'ZPARA!' to obtain YSI sonde parameter list into ParamCodeString. Requires
      'a second command, simply Z!, to obtain second line of data beyond first 8-9 parameters.
      Select Case WqSDIPort
      Case 3
        SDI12Recorder (SDIcodes(1),WqCom3,WqAddr,"ZPARA!",1.0,0,-1)
        SDI12Recorder (SDIcodes(2),WqCom3,WqAddr,"Z!",1.0,0,-1) 'Obtains any parameter codes beyond first 9
        SDI12Recorder (SDIcodes(3),WqCom3,WqAddr,"Z!",1.0,0,-1)
      Case 5
        SDI12Recorder (SDIcodes(1),WqCom3,WqAddr,"ZPARA!",1.0,0,-1)
        SDI12Recorder (SDIcodes(2),WqCom3,WqAddr,"Z!",1.0,0,-1) 'Obtains any parameter codes beyond first 9
        SDI12Recorder (SDIcodes(3),WqCom3,WqAddr,"Z!",1.0,0,-1)
      EndSelect
      SplitStr (SDIcodes(1),SDIcodes(1),"^M^J",1,6)
      SplitStr (SDIcodes(2),SDIcodes(2),"^M^J",1,7)
      SplitStr (SDIcodes(3),SDIcodes(3),"^M^J",1,7)
      SDIcodes(2) = Mid(SDIcodes(2),2,50)
      SDIcodes(3) = Mid(SDIcodes(3),2,50)
      FullSDICodes = SDIcodes(1) + SDIcodes(2) + SDIcodes(3)
      SplitStr (WqParamOrder(),FullSDICodes,"_",WqNParams,0)
    #EndIf 'End Serial or SDI12 conditional
    RedeployEnd = Timer(DebugTimer,mSec,4)
    RedeployEnd = RedeployEnd/1000
    RedeployTot = RedeployEnd - RedeployStart
  EndSub 'Parameter Check

  Sub DefineWqLocs 'Define Locations for parameter order
    DefineLocsStart = Timer(DebugTimer,mSec,4)
    DefineLocsStart = DefineLocsStart/1000
    WqLocDate = t(1)
    WqLocTime = t(2)
    WqLocTempC = t(3)
    WqLocTempF = t(4)
    WqLocSpC = t(5)
    WqLocTurbFNU = t(6)
    WqLocDOSat = t(7)
    WqLocDOmgL = t(8)
    WqLocDepthFt = t(9)
    WqLocDepthM = t(10)
    WqLocBatt = t(11)
    WqLocpH = t(12)
    WqLocpHmV = t(13)
    WqLocORP = t(14)
    WqLocChlugL = t(15)
    WqLocChlRFU = t(16)
    WqLocBGApcRFU = t(17)
    WqLocBGApcugL = t(18)
    WqLocFdomRFU = t(19)
    WqLocFdomQSU = t(20)
    WqLocNH4 = t(21)
    WqLocNO3 = t(22)
    WqLocCL = t(23)
    WqLocWiperPos = t(24)
    DefineLocsEnd = Timer(DebugTimer,mSec,4)
    DefineLocsEnd = DefineLocsEnd/1000
    DefineLocsTot = DefineLocsEnd - DefineLocsStart
  EndSub 'Define locations

  Sub DefineParamsOrder 'used to automatically determine which order parameters are coming in
    ParamOrdStart = Timer(DebugTimer,mSec,4)
    ParamOrdStart = ParamOrdStart/1000
    t(1) = FindSpa (DateCode,DateCode,1,WqParamOrder())
    t(2) = FindSpa (TimeCode,TimeCode,1,WqParamOrder())
    t(3) = FindSpa (TempCCode,TempCCode,1,WqParamOrder())
    t(4) = FindSpa (TempFcode,TempFcode,1,WqParamOrder())
    t(5) = FindSpa (SpCcode,SpCcode,1,WqParamOrder())
    t(6) = FindSpa (TurbFNUcode,TurbFNUcode,1,WqParamOrder())
    t(7) = FindSpa (DoSatCode,DoSatCode,1,WqParamOrder())
    t(8) = FindSpa (DOmgLCode,DOmgLCode,1,WqParamOrder())
    t(9) = FindSpa (DepthFtCode,DepthFtCode,1,WqParamOrder())
    t(10) = FindSpa (DepthMcode,DepthMcode,1,WqParamOrder())
    t(11) = FindSpa (BattCode,BattCode,1,WqParamOrder())
    t(12) = FindSpa (pHCode,pHCode,1,WqParamOrder())
    t(13) = FindSpa (pHmVcode,pHmVcode,1,WqParamOrder())
    t(14) = FindSpa (ORPCode,ORPCode,1,WqParamOrder())
    t(15) = FindSpa (ChlugLCode,ChlugLCode,1,WqParamOrder())
    t(16) = FindSpa (ChlRFUCode,ChlRFUCode,1,WqParamOrder())
    t(17) = FindSpa (BGApcRFUCode,BGApcRFUCode,1,WqParamOrder())
    t(18) = FindSpa (BGApcugLCode,BGApcugLCode,1,WqParamOrder())
    t(19) = FindSpa (FDomRFUcode,FDomRFUcode,1,WqParamOrder())
    t(20) = FindSpa (FDomQSU,FDomQSU,1,WqParamOrder())
    t(21) = FindSpa (NH4Code,NH4Code,1,WqParamOrder())
    t(22) = FindSpa (NO3Code,NO3Code,1,WqParamOrder())
    t(23) = FindSpa (CLCode,CLCode,1,WqParamOrder())
    t(24) = FindSpa (WiperPosCode,WiperPosCode,1,WqParamOrder())
    ParamOrdEnd = Timer(DebugTimer,mSec,4)
    ParamOrdEnd = ParamOrdEnd/1000
    ParamOrdTot = ParamOrdEnd - ParamOrdStart
  EndSub 'Define order

  Sub GetWQData 'gets single data point from EXO
    GetWQStart = Timer(DebugTimer,mSec,4)
    GetWQStart = GetWQStart/1000
    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then 'if we're using serial
      Call OpenWQPort
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setsonde 0"+CHR(13)+CHR(10),"OK",3,50)'communicate to top sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"data" + CHR(13) + CHR(10),"",1,10)'retrieve instant YSI filtered data point
      Delay (1,200,mSec)
      SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
      Erase WqData()
      WqIn = Trim(WqIn)
      SplitStr (WqData,WqIn,",",WqNParams,0)
      WqInLen = Len(WqIn)
      NoSondeTrig = InStr(1,WqIn,"Sonde",2)
      If NoSondeTrig <> 0 Then
        WqDataErr = "SOA: No Sonde!"
        Redeploy = True
        GetWQEnd = Timer(DebugTimer,mSec,4)
        GetWQEnd = GetWQEnd/1000
        GetWQTot = GetWQEnd - GetWQStart
        SerialFlush(WqSerialPort)
        Delay (1,20,mSec)
        ExitSub
      EndIf
      If WqInLen = 0 Then
        WqDataErr = "No response from sonde!"
        Redeploy = True
        GetWQEnd = Timer(DebugTimer,mSec,4)
        GetWQEnd = GetWQEnd/1000
        GetWQTot = GetWQEnd - GetWQStart
        Delay (1,20,mSec)
        SerialFlush(WqSerialPort)
        ExitSub
      EndIf
      Delay (1,20,mSec)
      SerialFlush(WqSerialPort)
    #ElseIf WqSonde = "WQ_SDI12" Then 'If we're using SDI12
      Select Case WqSDIPort 'based upon user choice
      Case 3
        SDI12Recorder (WqData(),WqCom3,WqAddr,"C!",1.0,0)
      Case 5
        SDI12Recorder (WqData(),WqCom5,WqAddr,"C!",1.0,0)
      EndSelect 'SDI12Port cases
    #EndIf 'End Serial or SDI12 conditional
    GetWQEnd = Timer(DebugTimer,mSec,4)
    GetWQEnd = GetWQEnd/1000
    GetWQTot = GetWQEnd - GetWQStart
  EndSub 'Get Data point

  Sub ParseWQData 'Parses data into correct locations
    ParseWQStart = Timer(DebugTimer,mSec,4)
    ParseWQStart = ParseWQStart/1000
    If WqData(WqLocDate) <> NAN AND WqData(WqLocDate)<> 0 AND WqData(WqLocTime)<> OldEXOTime  Then 'make sure data came in and timestamp doesn't match last minute
      OldEXOTime = WqData(WqLocTime) 'Set "OldEXOTime" to most recent value
      WqError = False 'no errors
      WqDead = False 'not "dead"
      WqErrCount = 0 'reset error count
      WqPwrCycleCnt = 0 'reset count since powercycle
    Else
      WqError = True
      WqErrCount = WqErrCount + 1
      WqPwrCycleCnt = WqPwrCycleCnt + 1
      If WqData(WqLocDate) = NAN Then
        WqDataErr = "LocDate = NAN!"
      EndIf
      If WqData(WqLocDate = 0) Then
        WqDataErr = "LocDate = 0!"
      EndIf
      #If DWRSonde = False Then
        If WqData(WqLocTime) = OldEXOTime Then
          WqDataErr = "Timestamp matches previous timestamp!"
        EndIf
      #EndIf
      OldEXOTime = WqData(WqLocTime)
      #If DWRSonde = False Then 'If it's a DWR sonde, assume "Sample and Hold", so don't mark data bad/exit the parse routine
        Call MarkWQBad
        ParseWQEnd = Timer(DebugTimer,mSec,4)
        ParseWQEnd = ParseWQEnd/1000
        ParseWQTot = ParseWQEnd - ParseWQStart
        ExitSub
      #EndIf
    EndIf 'If we have good data
    If WqLocDate > 0 Then WqDate = WqData(WqLocDate)
    If WqLocTime > 0 Then WqTime = WqData(WqLocTime)
    If WqLocTempC > 0 Then WqTempC = WqData(WqLocTempC)
    If WqLocTempF > 0 Then WqTempF = WqData(WqLocTempF)
    If WqLocSpC > 0 Then WqSpCond = WqData(WqLocSpC)
    If WqLocTurbFNU > 0 Then WqTurbFNU = WqData(WqLocTurbFNU)
    If WqLocDOSat > 0 Then WqDOsat = WqData(WqLocDOSat)
    If WqLocDOmgL > 0 Then WqDOmgL = WqData(WqLocDOmgL)
    If WqLocDepthFt > 0 Then WqDepthFt = WqData(WqLocDepthFt)
    If WqLocDepthM > 0 Then WqDepthM = WqData(WqLocDepthM)
    If WqLocBatt > 0 Then WqBattV = WqData(WqLocBatt)
    If WqLocpH > 0 Then WqpH = WqData(WqLocpH)
    If WqLocpHmV > 0 Then WqpHmV = WqData(WqLocpHmV)
    If WqLocORP > 0 Then WqORP = WqData(WqLocORP)
    If WqLocChlugL > 0 Then WqChlugL = WqData(WqLocChlugL)
    If WqLocChlRFU > 0 Then WqChlRFU = WqData(WqLocChlRFU)
    If WqLocBGApcRFU > 0 Then WqBGArfu = WqData(WqLocBGApcRFU)
    If WqLocBGApcugL > 0 Then WqBGAugL = WqData(WqLocBGApcugL)
    If WqLocFdomRFU > 0 Then WqFdomRFU = WqData(WqLocFdomRFU)
    If WqLocFdomQSU > 0 Then WqFdomQSU = WqData(WqLocFdomQSU)
    If WqLocNH4 > 0 Then WqNH4mgL = WqData(WqLocNH4)
    If WqLocNO3 > 0 Then WqNO3mgL = WqData(WqLocNO3)
    If WqLocCL > 0 Then WqCLmgL = WqData(WqLocCL)
    If WqLocWiperPos > 0 Then WqWiperPos = WqData(WqLocWiperPos)
    ParseWQEnd = Timer(DebugTimer,mSec,4)
    ParseWQEnd = ParseWQEnd/1000
    ParseWQTot = ParseWQEnd - ParseWQStart
  EndSub 'Parse data

  #If DWRSonde = False Then 'Don't mark data bad when DWR uses sample and hold
    Sub MarkWQBad 'if WQerror then NAN all wqdata
      MarkWQBadStart = Timer(DebugTimer,mSec,4)
      MarkWQBadStart = MarkWQBadStart/1000
      WqDate = ""
      WqTime = ""
      WqTempC = BadDataIndicator
      WqTempF = BadDataIndicator
      WqSpCond = BadDataIndicator
      WqTurbFNU = BadDataIndicator
      WqChlugL = BadDataIndicator
      WqChlRFU = BadDataIndicator
      WqDOmgL = BadDataIndicator
      WqDOsat = BadDataIndicator
      WqpH = BadDataIndicator
      WqpHmV = BadDataIndicator
      WqORP = BadDataIndicator
      WqDepthFt = BadDataIndicator
      WqDepthM = BadDataIndicator
      WqBattV = BadDataIndicator
      WqBGAugL = BadDataIndicator
      WqBGArfu = BadDataIndicator
      WqFdomRFU = BadDataIndicator
      WqFdomQSU = BadDataIndicator
      WqNH4mgL = BadDataIndicator
      WqNO3mgL = BadDataIndicator
      WqCLmgL = BadDataIndicator
      WqWiperPos = BadDataIndicator
      MarkWQBadEnd = Timer(DebugTimer,mSec,4)
      MarkWQBadEnd = MarkWQBadEnd/1000
      MarkWQBadTot = MarkWQBadEnd - MarkWQBadStart
    EndSub 'Mark data bad
  #EndIf

    #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then 'If serial communications
  '    Sub SetDelim 'sets the EXO to comma delimited output
  '      SetDelimStart = Timer(DebugTimer,mSec,4)
  '      SetDelimStart = SetDelimStart/1000
  '      Call OpenWQPort
  '      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
  '      Delay (1,10,mSec)
  '      SerialOut (WqSerialPort,"setsonde 0"+CHR(13)+CHR(10),"OK",3,50)'set to communicate to top sonde
  '      Delay (1,10,mSec)
  '      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
  '      Delay (1,10,mSec)
  '      SerialOut (WqSerialPort,"setdelim 2" + CHR(13) + CHR(10),"OK",3,50) 'set to comma delimited
  '      Delay (1,300,mSec)
  '      SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
  '      NoSondeTrig = InStr(1,WqIn,"Sonde",2)
  '      WqInLen = Len(WqIn)
  '      If NoSondeTrig <> 0 Then
  '        RedeployErr = "SOA: No Sonde!"
  '        Redeploy = True
  '      EndIf
  '      If WqInLen = 0 Then
  '        RedeployErr = "No response from sonde!"
  '        Redeploy = True
  '      EndIf
  '      Delay (1,20,mSec)
  '      SerialFlush(WqSerialPort)
  '      SetDelimEnd = Timer(DebugTimer,mSec,4)
  '      SetDelimEnd = SetDelimEnd/1000
  '      SetDelimTot = SetDelimEnd - SetDelimStart
  '    EndSub 'Set delimiter

  Sub WipeWq 'tells Wq to wipe
    WipeWqStart = Timer(DebugTimer,mSec,4)
    WipeWqStart = WipeWqStart/1000
    If Redeploy = True Then
      WipeWqStart = 0
      WipeWqEnd = 0
      WipeWqTot = 0
      ExitSub
    EndIf
    Dim WqDelay
    #If WqSonde = "WQ_SERIAL" Then
      If Mod15Minutes <> 840 Then
        WipeWqStart = 0
        WipeWqEnd = 0
        WipeWqTot = 0
        ExitSub 'If it's not the 14th minute
      EndIf
    #ElseIf WqSonde = "WQ_SERIAL_BURST" Then
      If Mod15Minutes <> 780 Then
        WipeWqStart = 0
        WipeWqEnd = 0
        WipeWqTot = 0
        ExitSub 'We want to wipe in the 13th minute for burst to occur in 14th minute
      EndIf
    #EndIf
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay(1,10,mSec)
    SerialOut (WqSerialPort,"setsonde 0" + CHR(13)+CHR(10),"OK",3,50)
    Delay(1,10,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"twipeb" + CHR(13) + CHR(10),"",1,0)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    SplitStr (WqDelay,WqIn,"",1,0)
    SerialFlush (WqSerialPort)
    SerialClose(WqSerialPort)
    WipeWqEnd = Timer(DebugTimer,mSec,4)
    WipeWqEnd = WipeWqEnd/1000
    WipeWqTot = WipeWqEnd - WipeWqStart
  EndSub 'wipe

  Sub SetEXOTime 'Subroutine to set the EXO clock to the datalogger clock to prevent drift
    If ModDay <> 0 Then
      SetEXOTimeStart = 0
      SetEXOTimeEnd = 0
      SetEXOTimeTot = 0
      ExitSub'if it isn't midnight, don't set clock
    EndIf
    SetEXOTimeStart = Timer(DebugTimer,mSec,4)
    SetEXOTimeStart = SetEXOTimeStart/1000
    Dim RawSetTime As String * 25 'define local variables to this routine
    Dim SplitTime(6) As Float
    Dim SendEXOHour As String
    Dim SendEXOMin As String
    Dim SendEXOSec As String
    Dim CalcHour As Float
    Dim EXOTimeString As String * 25
    RawSetTime = Status.Timestamp 'get latest time from datalogger
    SplitStr (SplitTime(),RawSetTime," ",6,0) 'take apart the time string
    CalcHour = SplitTime(4)
    If DWRSonde = False Then 'If it's not a DWR sonde
      CalcHour = CalcHour + 8 'add 8hr to datalogger timestamp to get to UTC
    Else
      CalcHour = CalcHour 'otherwise, leave datalogger timestamp to set to PST
    EndIf
    If CalcHour >= 24 Then CalcHour = CalcHour - 24

    If CalcHour < 10 Then 'add leading zero to hour
      SendEXOHour = "0" + CalcHour
    Else
      SendEXOHour = CalcHour
    EndIf
    If SplitTime(5) < 10 Then
      SendEXOMin = "0" + SplitTime(5)
    Else
      SendEXOMin = SplitTime(5)
    EndIf
    If Round(SplitTime(6),0) < 10 Then
      SendEXOSec = "0" + Round(SplitTime(6),0) 'eliminate fractional seconds
    Else
      SendEXOSec = Round(SplitTime(6),0)
    EndIf
    EXOTimeString = SendEXOHour + ":" + SendEXOMin + ":" + SendEXOSec 'Reconstruct UTC time string to send to EXO
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"setsonde 0" + CHR(13) + CHR(10),"OK",3,50)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"time " + EXOTimeString + CHR(13) + CHR(10),"OK",3,50)
    Delay (1,200,mSec)
    SerialFlush(WqSerialPort)
    If DWRSonde = False Then
      WqSysInfo = "Sonde time set at " + EXOTimeString + "UTC."
    Else
      WqSysInfo = "Sonde time set at " + EXOTimeString + "PST."
    EndIf
    SetEXOTimeEnd = Timer(DebugTimer,mSec,4)
    SetEXOTimeEnd = SetEXOTimeEnd/1000
    SetEXOTimeTot = SetEXOTimeEnd - SetEXOTimeStart
  EndSub 'clock set

  #If WqSonde = "WQ_SERIAL_BURST" Then 'If burst only
    'Define Burst related variables
    Dim GetBurst As Boolean
    Dim StartBurstTimer 'Timer name
    Dim BurstDelay 'Length of time to delay sampling into given minute
    Dim BurstData(WqNParams)
    Dim BurstArray(MaxBurstCnt,WqNParams)
    Dim BurstCount, BurstErrCnt, TotalBurstVals, BurstMaxErrCnt = 3, MinBurstVals = 4
    Dim StartBurst As Boolean

    'Declare Variables to store parsed burst data
    Dim BurstDate, BurstTime, BurstTempC, BurstTempF, BurstSpCond, BurstTurbFNU, BurstDOsat, BurstDOmgL, BurstDepthFt, BurstDepthM
    Dim BurstBattV, BurstORP, BurstpH, BurstpHmV, BurstChlugL, BurstChlRFU, BurstBGArfu, BurstBGAugL, BurstFdomRFU, BurstFdomQSU, BurstNH4mgL
    Dim BurstNO3mgL, BurstCLmgL, BurstWiperPos

    'Declare "Median" Variables to be pulled from Burst Table and Stored/Output in AQ Table
    Dim MedBurstDate, MedBurstTime, MedTempC, MedTempF, MedSpCond, MedTurbFNU, MedDOsat, MedDOmgL, MedDepthFt, MedDepthM, MedBattV
    Dim MedORP, MedpH, MedpHmV, MedChlugL, MedChlRFU, MedBGArfu, MedBGAugL, MedFdomRFU, MedFdomQSU, MedNH4mgL
    Dim MedNO3mgL, MedCLmgL, MedWiperPos

    Sub BurstStartTimer
      GetBurst = False
      If Mod15Minutes <> 840 Then ExitSub 'if the 14th minute
      Timer (StartBurstTimer,mSec,2) 'start timer for delaying the burst to later in the minute
      GetBurst = True
    EndSub

    Sub BurstDelayLoop
      If GetBurst = False OR Redeploy = True Then
        BurstDelayStart = 0
        BurstDelayEnd = 0
        BurstDelayTot = 0
        StartBurst = False
        ExitSub
      EndIf
      BurstDelayStart = Timer(DebugTimer,mSec,4)
      BurstDelayStart = BurstDelayStart/1000
      #If LoggerType = CR6 Then
        Dim BurstDelayCnt = 8
      #ElseIf LoggerType = CR1000 Then
        Dim BurstDelayCnt = 30
      #EndIf
      StartBurst = False
      Do
        BurstDelay = Timer(StartBurstTimer,mSec,4)
        BurstDelay = BurstDelay/1000
        If BurstDelay >= 60 - (MaxBurstCnt + BurstDelayCnt) Then 'delay until there will be a few seconds to spare at end of scan (sample rate is 1.15sec * 30 = 34.5seconds to complete)
          StartBurst = True
          ExitDo 'we reached out time threshold, start burst
        EndIf
        Delay(1,250,mSec) 'delay 0.25sec before checking time again
      Loop
      BurstDelayEnd = Timer(DebugTimer,mSec,4)
      BurstDelayEnd = BurstDelayEnd/1000
      BurstDelayTot = BurstDelayEnd - BurstDelayStart
    EndSub

    Sub SetBurst 'sets to run and receives string.
      If StartBurst = False OR Redeploy = True Then
        SetBurstStart = 0
        SetBurstEnd = 0
        SetBurstTot = 0
        ExitSub
      EndIf
      SetBurstStart = Timer(DebugTimer,mSec,4)
      SetBurstStart = SetBurstStart/1000
      If BurstPeriod = 0 Then
        BurstPeriod = 1150 'this is adjustable here and in the public table. Minimum value is 250 for the sonde. A cr6 seems to work at that rate or slower. A CR1000 needs a rate of no faster than 1150.
      ElseIf BurstPeriod < 250 Then 'if user enters values less than 250, but not 0, bring it up to 250. This is the max rate that the sonde can collect.
        BurstPeriod = 250
      EndIf
      Call OpenWQPort
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)'wake up SOA
      Delay (1,20,mSec)
      SerialOut (WqSerialPort,"setsonde 0" +CHR(13)+CHR(10),"OK",3,50)'communicate to top sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)'wake up SOA now that it is set to the top sonde
      Delay (1,10,mSec)
      SerialOut (WqSerialPort,"setperiod " + BurstPeriod + CHR(13) + CHR(10),"OK",3,50)
      Delay (1,200,msec)
      SerialOut (WqSerialPort,"#" + CHR(13),"#" + CHR(13),3,100)
      SerialOut (WqSerialPort,"run" + CHR(13),"run" + CHR(13),3,10) 'Starts the Wq sampling at 1Hz
      Delay (1,1,Sec)
      SetBurstEnd = Timer(DebugTimer,mSec,4)
      SetBurstEnd = SetBurstEnd/1000
      SetBurstTot = SetBurstEnd - SetBurstStart
    EndSub 'set burst period

    Sub BuildBurstArray 'Gets 30 second burst from sonde and stores in burst array
      If StartBurst = False Then
        BuildBurstStart = 0
        BuildBurstEnd = 0
        BuildBurstTot = 0
        ExitSub
      ElseIf Redeploy = True Then
        WqBurstErr = "Redeploy = True!"
        BuildBurstStart = 0
        BuildBurstEnd = 0
        BuildBurstTot = 0
        ExitSub
      EndIf
      BuildBurstStart = Timer(DebugTimer,mSec,4)
      BuildBurstStart = BuildBurstStart/1000
      Dim BurstIn As String * 256 'Raw EXO burst data string
      Dim Lcount As Long
      BurstCount = 0
      Erase BurstIn
      Erase BurstArray()
      WqSysInfo = "Burst start time = " + Status.Timestamp
      For Lcount = 1 To MaxBurstCnt
        SerialIn (BurstIn,WqSerialPort,100,"#",150)
        Delay(1,50,mSec)
        If BurstIn = "" Then
          WqError = True
          WqBurstErr = "No data from sonde!"
          ExitSub
        EndIf
        BurstIn = Replace (BurstIn,"-nan","-9999")
        SplitStr (BurstArray(Lcount,1),BurstIn,CHR(32),17,0)'parse the raw string and store in burst array (process after loop)
        Delay(1,20,mSec)
        Erase(BurstIn)
        SerialFlush(WqSerialPort)
        #If WqBaud = 9600 Then
          Delay(1,1100,mSec)'needs a little extra time at 9600 baud
        #ElseIf WqBaud = 38400
          Delay (1,930,mSec)
        #EndIf
        If Lcount >= MaxBurstCnt Then ExitFor
      Next Lcount
      Delay (1,20,mSec)
      SerialOut (WqSerialPort,"0" + CHR(13) + CHR(10),"#",3,50)
      SerialClose(WqSerialPort)
      BuildBurstEnd = Timer(DebugTimer,mSec,4)
      BuildBurstEnd = BuildBurstEnd/1000
      BuildBurstTot = BuildBurstEnd - BuildBurstStart
    EndSub 'fill BurstArray

    Sub DeconBurstArray
      If StartBurst = False Then
        DeconBurstStart = 0
        DeconBurstEnd = 0
        DeconBurstTot = 0
        ExitSub
      ElseIf Redeploy = True Then
        WqBurstErr = "Redeploy = True!"
        DeconBurstStart = 0
        DeconBurstEnd = 0
        DeconBurstTot = 0
        ExitSub
      ElseIf WqError = True Then
        WqBurstErr = "WqError flag is True!"
        DeconBurstStart = 0
        DeconBurstEnd = 0
        DeconBurstTot = 0
        ExitSub
      EndIf
      DeconBurstStart = Timer(DebugTimer,mSec,4)
      DeconBurstStart = DeconBurstStart/1000
      Dim jCount
      Dim kCount
      BurstCount = 0 'reset our burst counter
      TotalBurstVals = 0 'reset variable that will store how many values used to calculate burst table
      BurstErrCnt = 0 'reset error counter
      jCount = 0 'reset j Loop counter
      kCount = 0 'reset k Loop counter
      For jCount = 1 To MaxBurstCnt 'de-construct BurstArray and send to table.  too slow to do in get loop
        For kCount = 1 To WqNParams 'this is the loop to pull the parameters
          BurstData(kCount) = BurstArray(jCount,kCount)' get one burst string
        Next kCount 'pull all parameters within the k-th part of the j-loop and store in the array
        Call ParseBurst 'parse array into proper fields
        If WqError Then 'if we didn't get data
          BurstErrCnt = BurstErrCnt + 1
        EndIf
        BurstCount = BurstCount+1 'burst count increase
        If BurstErrCnt > BurstMaxErrCnt Then 'if we have more errors than the threshold
          TotalBurstVals = jCount - BurstErrCnt 'the total number of values used for the burst should be jCount - number of errors
          SerialOut (WqSerialPort,"0" + CHR(13) + CHR(10),"#",3,50) 'send a "0" out to stop the SOA from attempting to burst
          WqBurstErr = "BurstErrCnt > Threshold!"
          ExitFor 'if error occurs more than a threshold, exit the loop
        EndIf
        If BurstCount >= MaxBurstCnt Then 'if our burst count has reached our threshold
          TotalBurstVals = jCount - BurstErrCnt 'if there's an interuption during the burst but it comes back online, we need to subtract how many times error happened to calculate a total number of values
          BurstMissed = False 'we had good values coming in, so Make sure disable variable is set to false so the values get processed
          RecBurstFlag = True 'set our output flag to true
          CallTable SecBurst 'call the table that stores individual 1sec values
          CallTable Burst 'call the burst table
        ElseIf BurstCount < MaxBurstCnt AND WqError = True Then
          BurstMissed = False 'we have good values
          RecBurstFlag = False 'don't set the output flag because we haven't reached our threshold
          CallTable SecBurst 'store the next 1sec value
        ElseIf BurstCount < MaxBurstCnt AND WqError = False Then
          BurstMissed = False
          RecBurstFlag = False
          CallTable SecBurst
          CallTable Burst 'Need to call table to store the values in the table memory until the output flag (RecBurstFlag) is true
        EndIf
        Delay(1,1,msec)
      Next jCount 'restart the loop until we reach max burst count
      If BurstCount < MaxBurstCnt Then 'didn't reach our burst threshold, so let's Call and output SecBurst and Burst Tables
        BurstMissed = True 'Disable processing of Median values in burst table
        RecBurstFlag = True 'set the output flag to true
        WqBurstTableErr = "Number of values less than expected!"
        CallTable SecBurst 'store the final value in the SecBurst table
        CallTable Burst 'Call the burst table to output median values no with however many 1sec values were collected
      EndIf
      If TotalBurstVals >= MinBurstVals Then 'if we reached our minimum threshold for 1sec values
        Call CopyMedBurstVals 'copy the values from the burst table to the "Med..." values to be sampled into the AQ table
      Else
        Call ResetBurstVars 'we didn't reach our minimum threshold, NAN all values to be sampled into AQ table
        WqBurstAQErr = "Number of values less than threshold!"
      EndIf
      SerialFlush (WqSerialPort) 'flush the port to ensure nothing gets inadvertantly populated
      BurstCount = 0 'reset our burst count back to 0
      DeconBurstEnd = Timer(DebugTimer,mSec,4)
      DeconBurstEnd = DeconBurstEnd/1000
      DeconBurstTot = DeconBurstEnd - DeconBurstStart
    EndSub

    Sub ParseBurst 'Parses burst data into correct locations
      If StartBurst = False OR Redeploy = True Then
        ParseBurstStart = 0
        ParseBurstEnd = 0
        ParseBurstTot = 0
        ExitSub
      EndIf
      ParseBurstStart = Timer(DebugTimer,mSec,4)
      ParseBurstStart = ParseBurstStart/1000
      If BurstData(WqLocDate) <> NAN AND BurstData(WqLocDate) <> 0 Then
        WqError = False
        WqDead = False
        WqErrCount = 0
        WqPwrCycleCnt = 0
      ElseIf BurstData(WqLocDate) = NAN Then
        WqBurstErr = "LocDate = NAN!"
        WqError = True
      ElseIf BurstData(WqLocDate) = 0 Then
        WqBurstErr = "LocDate = 0!"
        WqError = True
      EndIf
      If WqLocDate > 0 Then BurstDate = BurstData(WqLocDate)
      If WqLocTime > 0 Then BurstTime = BurstData(WqLocTime)
      If WqLocTempC > 0 Then BurstTempC = BurstData(WqLocTempC)
      If WqLocTempF > 0 Then BurstTempF = BurstData(WqLocTempF)
      If WqLocSpC > 0 Then BurstSpCond = BurstData(WqLocSpC)
      If WqLocTurbFNU > 0 Then BurstTurbFNU = BurstData(WqLocTurbFNU)
      If WqLocDOSat > 0 Then BurstDOsat = BurstData(WqLocDOSat)
      If WqLocDOmgL > 0 Then BurstDOmgL = BurstData(WqLocDOmgL)
      If WqLocDepthFt > 0 Then BurstDepthFt = BurstData(WqLocDepthFt)
      If WqLocDepthM > 0 Then BurstDepthM = BurstData(WqLocDepthM)
      If WqLocBatt > 0 Then BurstBattV = BurstData(WqLocBatt)
      If WqLocpH > 0 Then BurstpH = BurstData(WqLocpH)
      If WqLocpHmV > 0 Then BurstpHmV = BurstData(WqLocpHmV)
      If WqLocORP > 0 Then BurstORP = BurstData(WqLocORP)
      If WqLocChlugL > 0 Then BurstChlugL = BurstData(WqLocChlugL)
      If WqLocChlRFU > 0 Then BurstChlRFU = BurstData(WqLocChlRFU)
      If WqLocBGApcRFU > 0 Then BurstBGArfu = BurstData(WqLocBGApcRFU)
      If WqLocBGApcugL > 0 Then BurstBGAugL = BurstData(WqLocBGApcugL)
      If WqLocFdomRFU > 0 Then BurstFdomRFU = BurstData(WqLocFdomRFU)
      If WqLocFdomQSU > 0 Then BurstFdomQSU = BurstData(WqLocFdomQSU)
      If WqLocNH4 > 0 Then BurstNH4mgL = BurstData(WqLocNH4)
      If WqLocNO3 > 0 Then BurstNO3mgL = BurstData(WqLocNO3)
      If WqLocCL > 0 Then BurstCLmgL = BurstData(WqLocCL)
      If WqLocWiperPos > 0 Then BurstWiperPos = BurstData(WqLocWiperPos)
      ParseBurstEnd = Timer(DebugTimer,mSec,4)
      ParseBurstEnd = ParseBurstEnd/1000
      ParseBurstTot = ParseBurstEnd - ParseBurstStart
    EndSub 'Parse burst

    Sub CopyMedBurstVals 'Copy values from "Burst" table to holder for AQ table
      If StartBurst = False OR Redeploy = True Then
        CopyBurstStart = 0
        CopyBurstEnd = 0
        CopyBurstTot = 0
        ExitSub
      EndIf
      CopyBurstStart = Timer(DebugTimer,mSec,4)
      CopyBurstStart = CopyBurstStart/1000
      MedBurstDate = Burst.BurstDate_Med
      MedBurstTime = Burst.BurstTime_Med
      MedBurstTime = Round(MedBurstTime,0) 'round the time because the median value of an even set of numbers is the average of the two median values
      MedTempC = Burst.BurstTempC_Med
      MedTempF = Burst.BurstTempF_Med
      MedSpCond = Burst.BurstSpCond_Med
      MedTurbFNU = Burst.BurstTurbFNU_Med
      MedDOsat = Burst.BurstDOSat_Med
      MedDOmgL= Burst.BurstDOmgL_Med
      MedORP= Burst.BurstORP_Med
      MedDepthFt = Burst.BurstDepthFt_Med
      MedDepthM = Burst.BurstDepthM_Med
      MedBattV= Burst.BurstBattV_Med
      MedpH= Burst.BurstpH_Med
      MedpHmV= Burst.BurstpHmV_Med
      MedChlugL= Burst.BurstChlugL_Med
      MedChlRFU= Burst.BurstChlRFU_Med
      MedBGArfu= Burst.BurstBGARFU_Med
      MedBGAugL= Burst.BurstBGAugL_Med
      MedFdomRFU= Burst.BurstFdomRFU_Med
      MedFdomQSU= Burst.BurstFDomQSU_Med
      MedNH4mgL= Burst.BurstNH4mgl_Med
      MedNO3mgL= Burst.BurstNO3mgl_Med
      MedCLmgL= Burst.BurstCLmgl_Med
      MedWiperPos= Burst.BurstWiperPos_Med
      CopyBurstEnd = Timer(DebugTimer,mSec,4)
      CopyBurstEnd = CopyBurstEnd/1000
      CopyBurstTot = CopyBurstEnd - CopyBurstStart
    EndSub 'copy from Burst table to variable for AQ

    Sub ResetBurstVars 'Reset Burst Variables to NANs
      ResetBurstStart = Timer(DebugTimer,mSec,4)
      ResetBurstStart = ResetBurstStart/1000
      MedBurstDate = BadDataIndicator
      MedBurstTime = BadDataIndicator
      MedTempC = BadDataIndicator
      MedTempF = BadDataIndicator
      MedSpCond = BadDataIndicator
      MedTurbFNU = BadDataIndicator
      MedDOsat = BadDataIndicator
      MedDOmgL= BadDataIndicator
      MedORP= BadDataIndicator
      MedDepthFt = BadDataIndicator
      MedDepthM = BadDataIndicator
      MedBattV= BadDataIndicator
      MedpH= BadDataIndicator
      MedpHmV= BadDataIndicator
      MedChlugL= BadDataIndicator
      MedChlRFU= BadDataIndicator
      MedBGArfu= BadDataIndicator
      MedBGAugL= BadDataIndicator
      MedFdomRFU= BadDataIndicator
      MedFdomQSU= BadDataIndicator
      MedNH4mgL= BadDataIndicator
      MedNO3mgL= BadDataIndicator
      MedCLmgL= BadDataIndicator
      MedWiperPos= BadDataIndicator
      ResetBurstEnd = Timer(DebugTimer,mSec,4)
      ResetBurstEnd = ResetBurstEnd/1000
      ResetBurstTot = ResetBurstEnd - ResetBurstStart
    EndSub 'reset to NANs
  #EndIf 'If Burst only
#EndIf 'If serial communications
#EndIf  'If we have a sonde or not

BeginProg
  SiteID = "TEST"
  SiteNum = 12345678
  #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
    Call OpenWQPort 'Open serial port based on LoggerType, Baudrates, and Max232 presencej
  #EndIf
  Scan (1,Min,0,0)
    Timer(DebugTimer,mSec,2)
    Call ModTiming
    Battery (StationVolts)
    PanelTemp(LoggerTempC,60)
    #If WqSonde <> "NONE" Then
      Call PowerWqSonde
      #If WqSonde = "WQ_SERIAL_BURST" Then
        Call BurstStartTimer
      #EndIf
      #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then 'if serial
        Call SetEXOTime 'we can set the clock
      #EndIf
      If Redeploy = True Then 'Don't try to get parameters in same minute sonde was cycled. needs 19s for warmup
        Redeploy = False
        Call Redeployment
        Delay (1,10,mSec)
        Call DefineParamsOrder
        Delay (1,10,mSec)
        Call DefineWqLocs
        Delay (1,10,mSec)
      EndIf
      If WqErrCount >= MaxWqErrCnt AND WqPwrCycleCnt >= MaxWqErrCnt OR WqManualCycle = True Then
        Call CycleWqPower
      EndIf
      If RedeployErr = "" Then 'only attempt to get data if there wasn't an error in redeployment
      Call GetWQData 'get a single data point
      Call ParseWQData 'Parse the data
      EndIf
      #If WqSonde = "WQ_SERIAL" OR WqSonde = "WQ_SERIAL_BURST" Then
        Call WipeWQ 'Call for wipe AFTER we get a data point (until we build logic to handle this before, if we want)
      #EndIf
      Delay (1,30,mSec)
      #If WqSonde = "WQ_SERIAL_BURST" Then
        Call BurstDelayLoop
        Call SetBurst
        Call BuildBurstArray
        Call DeconBurstArray
        Call ParseBurst
      #EndIf
    #EndIf
    CallTable SVMaq
    CallTable Aquarius
    ScanTot = Timer(DebugTimer,mSec,4)
    ScanTot = ScanTot/1000
    CallTable Debugger
    Call ResetTimers
    Call ResetErr
  NextScan
EndProg

